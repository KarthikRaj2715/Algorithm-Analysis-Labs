# -*- coding: utf-8 -*-
"""SC2001 Part 2 Thiru.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nO1cLvkd61nMHwZ8T1sbo32yrXwOC1_L

## **Part A Empirical Analysis**
"""

import numpy as np
import matplotlib.pyplot as plt
import timeit
import random

def generate_graph(n, p):
    """Generates a random graph using the Erdős–Rényi model G(n, p)."""
    matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            if random.random() <= p:
                weight = random.randint(1, 100)
                matrix[i][j] = weight
                matrix[j][i] = weight
    return matrix

def dijkstra_with_array_pq(adj_matrix, source):
    """Dijkstra's algorithm using an adjacency matrix and array-based priority queue."""
    n = len(adj_matrix)
    distances = [float('inf')] * n
    distances[source] = 0
    visited = [False] * n
    pq = [(0, source)]

    while pq:
        # Sort to find the minimum distance
        pq.sort(key=lambda x: x[0])
        current_dist, u = pq.pop(0)
        if visited[u]:
            continue
        visited[u] = True
        for v in range(n):
            if adj_matrix[u][v] > 0 and not visited[v]:
                new_dist = current_dist + adj_matrix[u][v]
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    pq.append((new_dist, v))
    return distances

def analyze_performance(range_values, p, fixed_v=False):
    times = []
    if fixed_v:
        n = fixed_v
        for prob in range_values:
            graph = generate_graph(n, prob)
            start_time = timeit.default_timer()
            dijkstra_with_array_pq(graph, 0)
            times.append(timeit.default_timer() - start_time)
    else:
        for n in range_values:
            graph = generate_graph(n, p)
            start_time = timeit.default_timer()
            dijkstra_with_array_pq(graph, 0)
            times.append(timeit.default_timer() - start_time)
    return times

def theoretical_time_complexity(vertex_counts):
  theoretical_times = []
  for v in vertex_counts:
      time_complexity = (v ** 2)  # O(V^2)
      theoretical_times.append(time_complexity)
  return theoretical_times

# Parameters for the analysis
vertex_range = range(1, 101)  # Varying V from 1 to 100
prob_range = np.linspace(0, 1, 11)  # Varying probability from 0 to 1

# Perform analyses
low_p_times = analyze_performance(vertex_range, 0.1)  # Low edge probability with varying V
high_p_times = analyze_performance(vertex_range, 1.0)  # High edge probability with varying V
fixed_10_times = analyze_performance(prob_range, None, fixed_v=10)  # Fixed V=10 with varying E probability
fixed_100_times = analyze_performance(prob_range, None, fixed_v=100)  # Fixed V=100 with varying E probability

# Plotting results
fig, axs = plt.subplots(2, 2, figsize=(12, 12))
axs[0, 0].plot(vertex_range, low_p_times)
axs[0, 0].set_title('Low Edge Probability with Varying V')
axs[0, 0].set_xlabel('Number of Vertices')
axs[0, 0].set_ylabel('Time (seconds)')

axs[0, 1].plot(vertex_range, high_p_times)
axs[0, 1].set_title('High Edge Probability with Varying V')
axs[0, 1].set_xlabel('Number of Vertices')
axs[0, 1].set_ylabel('Time (seconds)')

axs[1, 0].plot(prob_range, fixed_10_times)
axs[1, 0].set_title('Varying Edge Probability with V=10')
axs[1, 0].set_xlabel('Edge Probability')
axs[1, 0].set_ylabel('Time (seconds)')

axs[1, 1].plot(prob_range, fixed_100_times)
axs[1, 1].set_title('Varying Edge Probability with V=100')
axs[1, 1].set_xlabel('Edge Probability')
axs[1, 1].set_ylabel('Time (seconds)')

plt.tight_layout()
plt.show()

"""## **Part A Theory + Emphircal**"""

import numpy as np
import matplotlib.pyplot as plt
import timeit
import random

def generate_graph(n, p):
    """Generates a random graph using the Erdős–Rényi model G(n, p)."""
    matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            if random.random() <= p:
                weight = random.randint(1, 100)
                matrix[i][j] = weight
                matrix[j][i] = weight
    return matrix

def dijkstra_with_array_pq(adj_matrix, source):
    """Dijkstra's algorithm using an adjacency matrix and array-based priority queue."""
    n = len(adj_matrix)
    distances = [float('inf')] * n
    distances[source] = 0
    visited = [False] * n
    pq = [(0, source)]

    while pq:
        # Sort to find the minimum distance
        pq.sort(key=lambda x: x[0])
        current_dist, u = pq.pop(0)
        if visited[u]:
            continue
        visited[u] = True
        for v in range(n):
            if adj_matrix[u][v] > 0 and not visited[v]:
                new_dist = current_dist + adj_matrix[u][v]
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    pq.append((new_dist, v))
    return distances

def analyze_performance(range_values, p, fixed_v=False):
    times = []
    if fixed_v:
        n = fixed_v
        for prob in range_values:
            graph = generate_graph(n, prob)
            start_time = timeit.default_timer()
            dijkstra_with_array_pq(graph, 0)
            times.append(timeit.default_timer() - start_time)
    else:
        for n in range_values:
            graph = generate_graph(n, p)
            start_time = timeit.default_timer()
            dijkstra_with_array_pq(graph, 0)
            times.append(timeit.default_timer() - start_time)
    return times

def theoretical_time_complexity(vertex_counts):
    theoretical_times = []
    for v in vertex_counts:
        time_complexity = (v ** 2)  # O(V^2)
        theoretical_times.append(time_complexity)
    return theoretical_times

# Parameters for the analysis
vertex_range = range(1, 101)  # Varying V from 1 to 100
prob_range = np.linspace(0, 1, 11)  # Varying probability from 0 to 1

# Perform analyses
low_p_times = analyze_performance(vertex_range, 0.1)  # Low edge probability with varying V
high_p_times = analyze_performance(vertex_range, 1.0)  # High edge probability with varying V
fixed_10_times = analyze_performance(prob_range, None, fixed_v=10)  # Fixed V=10 with varying E probability
fixed_100_times = analyze_performance(prob_range, None, fixed_v=100)  # Fixed V=100 with varying E probability

# Theoretical time complexity for vertex varying cases (low_p_times and high_p_times)
theoretical_times = theoretical_time_complexity(vertex_range)

# Theoretical time complexity for fixed vertex cases (fixed_10_times and fixed_100_times)
theoretical_10 = [10**2] * len(prob_range)  # O(V^2) for V=10
theoretical_100 = [100**2] * len(prob_range)  # O(V^2) for V=100

# Plotting results with theoretical complexity
fig, axs = plt.subplots(2, 2, figsize=(12, 12))

# Low edge probability with varying V
axs[0, 0].plot(vertex_range, low_p_times, label='Empirical')
axs[0, 0].plot(vertex_range, theoretical_times, label='Theoretical O(V^2)', linestyle='--')
axs[0, 0].set_title('Low Edge Probability with Varying V')
axs[0, 0].set_xlabel('Number of Vertices')
axs[0, 0].set_ylabel('Time (seconds)')
axs[0, 0].legend()

# High edge probability with varying V
axs[0, 1].plot(vertex_range, high_p_times, label='Empirical')
axs[0, 1].plot(vertex_range, theoretical_times, label='Theoretical O(V^2)', linestyle='--')
axs[0, 1].set_title('High Edge Probability with Varying V')
axs[0, 1].set_xlabel('Number of Vertices')
axs[0, 1].set_ylabel('Time (seconds)')
axs[0, 1].legend()

# Varying Edge Probability with V=10
axs[1, 0].plot(prob_range, fixed_10_times, label='Empirical')
axs[1, 0].plot(prob_range, theoretical_10, label='Theoretical O(V^2)', linestyle='--')
axs[1, 0].set_title('Varying Edge Probability with V=10')
axs[1, 0].set_xlabel('Edge Probability')
axs[1, 0].set_ylabel('Time (seconds)')
axs[1, 0].legend()

# Varying Edge Probability with V=100
axs[1, 1].plot(prob_range, fixed_100_times, label='Empirical')
axs[1, 1].plot(prob_range, theoretical_100, label='Theoretical O(V^2)', linestyle='--')
axs[1, 1].set_title('Varying Edge Probability with V=100')
axs[1, 1].set_xlabel('Edge Probability')
axs[1, 1].set_ylabel('Time (seconds)')
axs[1, 1].legend()

plt.tight_layout()
plt.show()

"""## **Part B Emphirical Analysis**"""

# use same list for both empirical and theory list func in karthik collab


import numpy as np
import matplotlib.pyplot as plt
import timeit
import random
import heapq

def generate_adjacency_list(n, p):
    """Generates a random graph represented as an adjacency list using the Erdős–Rényi model G(n, p)."""
    adjacency_list = {i: [] for i in range(n)}
    for i in range(n):
        for j in range(i + 1, n):
            if random.random() <= p:
                weight = random.randint(1, 100)
                adjacency_list[i].append((j, weight))
                adjacency_list[j].append((i, weight))
    return adjacency_list

def dijkstra_with_heap_pq(adj_list, source):
    """Dijkstra's algorithm using an adjacency list and a heap-based priority queue."""
    n = len(adj_list)
    distances = [float('inf')] * n
    distances[source] = 0
    pq = [(0, source)]
    visited = [False] * n

    while pq:
        current_dist, u = heapq.heappop(pq)
        if visited[u]:
            continue
        visited[u] = True
        for v, weight in adj_list[u]:
            if not visited[v]:
                new_dist = current_dist + weight
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    heapq.heappush(pq, (new_dist, v))
    return distances

def analyze_performance(range_values, p, fixed_v=False):
    times = []
    if fixed_v:
        n = fixed_v
        for prob in range_values:
            adj_list = generate_adjacency_list(n, prob)
            start_time = timeit.default_timer()
            dijkstra_with_heap_pq(adj_list, 0)
            times.append(timeit.default_timer() - start_time)
    else:
        for n in range_values:
            adj_list = generate_adjacency_list(n, p)
            start_time = timeit.default_timer()
            dijkstra_with_heap_pq(adj_list, 0)
            times.append(timeit.default_timer() - start_time)
    return times

# Parameters for the analysis
vertex_range = range(1, 101)  # Varying V from 1 to 100
prob_range = np.linspace(0, 1, 11)  # Varying probability from 0 to 1

# Perform analyses
low_p_times = analyze_performance(vertex_range, 0.1)  # Low edge probability with varying V
high_p_times = analyze_performance(vertex_range, 1.0)  # High edge probability with varying V
fixed_10_times = analyze_performance(prob_range, None, fixed_v=10)  # Fixed V=10 with varying E probability
fixed_100_times = analyze_performance(prob_range, None, fixed_v=100)  # Fixed V=100 with varying E probability

# Plotting results
fig, axs = plt.subplots(2, 2, figsize=(12, 12))
axs[0, 0].plot(vertex_range, low_p_times)
axs[0, 0].set_title('Low Edge Probability with Varying V')
axs[0, 0].set_xlabel('Number of Vertices')
axs[0, 0].set_ylabel('Time (seconds)')

axs[0, 1].plot(vertex_range, high_p_times)
axs[0, 1].set_title('High Edge Probability with Varying V')
axs[0, 1].set_xlabel('Number of Vertices')
axs[0, 1].set_ylabel('Time (seconds)')

axs[1, 0].plot(prob_range, fixed_10_times)
axs[1, 0].set_title('Varying Edge Probability with V=10')
axs[1, 0].set_xlabel('Edge Probability')
axs[1, 0].set_ylabel('Time (seconds)')

axs[1, 1].plot(prob_range, fixed_100_times)
axs[1, 1].set_title('Varying Edge Probability with V=100')
axs[1, 1].set_xlabel('Edge Probability')
axs[1, 1].set_ylabel('Time (seconds)')

plt.tight_layout()
plt.show()

"""## Part B **Emphirical + Theory**"""

import numpy as np
import matplotlib.pyplot as plt
import timeit
import random
import heapq
import math

def generate_adjacency_list(n, p):
    """Generates a random graph represented as an adjacency list using the Erdős–Rényi model G(n, p)."""
    adjacency_list = {i: [] for i in range(n)}
    edge_count = 0
    for i in range(n):
        for j in range(i + 1, n):
            if random.random() <= p:
                weight = random.randint(1, 100)
                adjacency_list[i].append((j, weight))
                adjacency_list[j].append((i, weight))
                edge_count += 1
    return adjacency_list, edge_count

def dijkstra_with_heap_pq(adj_list, source):
    """Dijkstra's algorithm using an adjacency list and a heap-based priority queue."""
    n = len(adj_list)
    distances = [float('inf')] * n
    distances[source] = 0
    pq = [(0, source)]
    visited = [False] * n

    while pq:
        current_dist, u = heapq.heappop(pq)
        if visited[u]:
            continue
        visited[u] = True
        for v, weight in adj_list[u]:
            if not visited[v]:
                new_dist = current_dist + weight
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    heapq.heappush(pq, (new_dist, v))
    return distances

def analyze_performance(range_values, p, fixed_v=False):
    times = []
    edge_counts = []
    if fixed_v:
        n = fixed_v
        for prob in range_values:
            adj_list, edge_count = generate_adjacency_list(n, prob)
            start_time = timeit.default_timer()
            dijkstra_with_heap_pq(adj_list, 0)
            times.append(timeit.default_timer() - start_time)
            edge_counts.append(edge_count)
    else:
        for n in range_values:
            adj_list, edge_count = generate_adjacency_list(n, p)
            start_time = timeit.default_timer()
            dijkstra_with_heap_pq(adj_list, 0)
            times.append(timeit.default_timer() - start_time)
            edge_counts.append(edge_count)
    return times, edge_counts

def theoretical_time_complexity_heap(vertex_counts, edge_counts):
    theoretical_times = []
    for i in range(len(vertex_counts)):
        v = vertex_counts[i]
        e = edge_counts[i]
        time_complexity = (v + e) * math.log(v)  # O((V + E) log V)
        theoretical_times.append(time_complexity)
    return theoretical_times

# Parameters for the analysis
vertex_range = range(1, 101)  # Varying V from 1 to 100
prob_range = np.linspace(0, 1, 11)  # Varying probability from 0 to 1

# Perform analyses
low_p_times, low_p_edges = analyze_performance(vertex_range, 0.1)  # Low edge probability with varying V
high_p_times, high_p_edges = analyze_performance(vertex_range, 1.0)  # High edge probability with varying V
fixed_10_times, fixed_10_edges = analyze_performance(prob_range, None, fixed_v=10)  # Fixed V=10 with varying E probability
fixed_100_times, fixed_100_edges = analyze_performance(prob_range, None, fixed_v=100)  # Fixed V=100 with varying E probability

# Theoretical time complexity
theoretical_low_p = theoretical_time_complexity_heap(vertex_range, low_p_edges)
theoretical_high_p = theoretical_time_complexity_heap(vertex_range, high_p_edges)
theoretical_10 = theoretical_time_complexity_heap([10] * len(prob_range), fixed_10_edges)
theoretical_100 = theoretical_time_complexity_heap([100] * len(prob_range), fixed_100_edges)

# Plotting results
fig, axs = plt.subplots(2, 2, figsize=(12, 12))

# Low edge probability with varying V
axs[0, 0].plot(vertex_range, low_p_times, label='Empirical')
axs[0, 0].plot(vertex_range, theoretical_low_p, label='Theoretical O((V+E)logV)', linestyle='--')
axs[0, 0].set_title('Low Edge Probability with Varying V')
axs[0, 0].set_xlabel('Number of Vertices')
axs[0, 0].set_ylabel('Time (seconds)')
axs[0, 0].legend()

# High edge probability with varying V
axs[0, 1].plot(vertex_range, high_p_times, label='Empirical')
axs[0, 1].plot(vertex_range, theoretical_high_p, label='Theoretical O((V+E)logV)', linestyle='--')
axs[0, 1].set_title('High Edge Probability with Varying V')
axs[0, 1].set_xlabel('Number of Vertices')
axs[0, 1].set_ylabel('Time (seconds)')
axs[0, 1].legend()

# Varying Edge Probability with V=10
axs[1, 0].plot(prob_range, fixed_10_times, label='Empirical')
axs[1, 0].plot(prob_range, theoretical_10, label='Theoretical O((V+E)logV)', linestyle='--')
axs[1, 0].set_title('Varying Edge Probability with V=10')
axs[1, 0].set_xlabel('Edge Probability')
axs[1, 0].set_ylabel('Time (seconds)')
axs[1, 0].legend()

# Varying Edge Probability with V=100
axs[1, 1].plot(prob_range, fixed_100_times, label='Empirical')
axs[1, 1].plot(prob_range, theoretical_100, label='Theoretical O((V+E)logV)', linestyle='--')
axs[1, 1].set_title('Varying Edge Probability with V=100')
axs[1, 1].set_xlabel('Edge Probability')
axs[1, 1].set_ylabel('Time (seconds)')
axs[1, 1].legend()

plt.tight_layout()
plt.show()

"""## Test

## **Part A test**
"""

import sys
import random
import time
import matplotlib.pyplot as plt

# Function to generate a sparse or dense graph with varying vertices and edges
def generate_graph(vertices, edges, dense=False):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0

    if dense:
        max_edges = vertices * (vertices - 1) // 2  # Max possible edges in a complete graph
        edges = min(edges, max_edges)

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight
            graph[v][u] = weight  # Undirected graph
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency matrix and array for priority queue
def dijkstra_matrix(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices

    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1

        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v

        u = min_index
        visited[u] = True

        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]

    return dist

# Measure the execution time for different vertex and edge sizes
def measure_time_matrix():
    vertices_range = list(range(10, 101, 10))
    time_results_sparse = []
    time_results_dense = []

    for v in vertices_range:
        sparse_graph = generate_graph(v, v - 1)
        dense_graph = generate_graph(v, v * (v - 1) // 2, dense=True)

        start_time = time.time()
        dijkstra_matrix(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        start_time = time.time()
        dijkstra_matrix(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return vertices_range, time_results_sparse, time_results_dense

# Plotting results for Part A
def plot_results_part_a():
    vertices_range, time_sparse, time_dense = measure_time_matrix()

    plt.plot(vertices_range, time_sparse, label="Sparse Graph (Adj Matrix)")
    plt.plot(vertices_range, time_dense, label="Dense Graph (Adj Matrix)")
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm with Adjacency Matrix')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_a()

"""## **Part B Test**"""

import heapq
import random
import time
import matplotlib.pyplot as plt

# Function to generate a sparse or dense graph as adjacency list
def generate_graph_adj_list(vertices, edges, dense=False):
    graph = {i: [] for i in range(vertices)}
    edge_count = 0

    if dense:
        max_edges = vertices * (vertices - 1) // 2  # Max possible edges in a complete graph
        edges = min(edges, max_edges)

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and all(v != dest for dest, _ in graph[u]):
            weight = random.randint(1, 10)
            graph[u].append((v, weight))
            graph[v].append((u, weight))  # Undirected graph
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency list and min-heap for priority queue
def dijkstra_list(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    priority_queue = [(0, src)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)

        if current_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            distance = current_dist + weight
            if distance < dist[v]:
                dist[v] = distance
                heapq.heappush(priority_queue, (distance, v))

    return dist

# Measure the execution time for different vertex and edge sizes
def measure_time_list():
    vertices_range = list(range(10, 101, 10))
    time_results_sparse = []
    time_results_dense = []

    for v in vertices_range:
        sparse_graph = generate_graph_adj_list(v, v - 1)
        dense_graph = generate_graph_adj_list(v, v * (v - 1) // 2, dense=True)

        start_time = time.time()
        dijkstra_list(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        start_time = time.time()
        dijkstra_list(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return vertices_range, time_results_sparse, time_results_dense

# Plotting results for Part B
def plot_results_part_b():
    vertices_range, time_sparse, time_dense = measure_time_list()

    plt.plot(vertices_range, time_sparse, label="Sparse Graph (Adj List)")
    plt.plot(vertices_range, time_dense, label="Dense Graph (Adj List)")
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm with Adjacency List')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_b()

"""## **Part A Test 2**"""

import sys
import random
import time
import matplotlib.pyplot as plt

# Function to generate a sparse or dense directed graph
def generate_directed_graph(vertices, edges):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight  # Directed graph, only u -> v
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency matrix for directed graph
def dijkstra_matrix_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices

    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1

        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v

        u = min_index
        visited[u] = True

        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]

    return dist

# Measure the execution time for varying vertices for sparse and dense directed graphs
def measure_time_matrix_directed(vertex_range):
    time_results_sparse = []
    time_results_dense = []

    for v in vertex_range:
        sparse_edges = v - 1  # Sparse graph with v-1 edges
        dense_edges = v * (v - 1) // 2  # Dense graph with max edges for directed graph

        sparse_graph = generate_directed_graph(v, sparse_edges)
        dense_graph = generate_directed_graph(v, dense_edges)

        # Measure time for sparse graph
        start_time = time.time()
        dijkstra_matrix_directed(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        # Measure time for dense graph
        start_time = time.time()
        dijkstra_matrix_directed(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return time_results_sparse, time_results_dense

# Plotting results for vertices from 1 to 1000
def plot_results_part_a():
    vertex_range = list(range(1, 1001))  # Vertices from 1 to 1000
    time_sparse, time_dense = measure_time_matrix_directed(vertex_range)

    plt.plot(vertex_range, time_sparse, label="Sparse Graph (Directed)")
    plt.plot(vertex_range, time_dense, label="Dense Graph (Directed)")
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm: Sparse vs Dense (Vertices 1 to 1000)')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_a()

import sys
import random
import time
import matplotlib.pyplot as plt

# Function to generate a sparse or dense directed graph with varying vertices and edges
def generate_directed_graph(vertices, edges):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight  # Directed graph, only u -> v
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency matrix for directed graph
def dijkstra_matrix_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices

    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1

        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v

        u = min_index
        visited[u] = True

        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]

    return dist

# Measure the execution time for varying vertices for sparse and dense directed graphs
def measure_time_matrix_directed(vertex_range):
    time_results_sparse = []
    time_results_dense = []

    for v in vertex_range:
        sparse_edges = v - 1  # Sparse graph with v-1 edges
        dense_edges = v * (v - 1)  # Dense graph with max edges for directed graph

        sparse_graph = generate_directed_graph(v, sparse_edges)
        dense_graph = generate_directed_graph(v, dense_edges)

        # Measure time for sparse graph
        start_time = time.time()
        dijkstra_matrix_directed(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        # Measure time for dense graph
        start_time = time.time()
        dijkstra_matrix_directed(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return time_results_sparse, time_results_dense

# Plotting results for vertices from 50 to 1000 in increments of 50
def plot_results_part_a():
    vertex_range = list(range(50, 1001, 50))  # Vertices from 50 to 1000 in increments of 50
    time_sparse, time_dense = measure_time_matrix_directed(vertex_range)

    plt.plot(vertex_range, time_sparse, label="Sparse Graph (Directed, Matrix)")
    plt.plot(vertex_range, time_dense, label="Dense Graph (Directed, Matrix)")
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency Matrix): Sparse vs Dense (Vertices 50 to 1000)')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_a()

import sys
import random
import time
import matplotlib.pyplot as plt
import numpy as np

# Function to generate a sparse or dense directed graph with varying vertices and edges
def generate_directed_graph(vertices, edges):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight  # Directed graph, only u -> v
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency matrix for directed graph
def dijkstra_matrix_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices

    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1

        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v

        u = min_index
        visited[u] = True

        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]

    return dist

# Measure the execution time for varying vertices for sparse and dense directed graphs
def measure_time_matrix_directed(vertex_range):
    time_results_sparse = []
    time_results_dense = []

    for v in vertex_range:
        sparse_edges = v - 1  # Sparse graph with v-1 edges
        dense_edges = v * (v - 1)  # Dense graph with max edges for directed graph

        sparse_graph = generate_directed_graph(v, sparse_edges)
        dense_graph = generate_directed_graph(v, dense_edges)

        # Measure time for sparse graph
        start_time = time.time()
        dijkstra_matrix_directed(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        # Measure time for dense graph
        start_time = time.time()
        dijkstra_matrix_directed(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return time_results_sparse, time_results_dense

# Function to add polynomial best-fit line
def polynomial_fit(x, y, degree):
    coefficients = np.polyfit(x, y, degree)
    polynomial = np.poly1d(coefficients)
    return polynomial(x)

# Plotting results for vertices from 50 to 1000 in increments of 50 with best-fit line
def plot_results_part_a_with_fit():
    vertex_range = list(range(50, 1001, 50))  # Vertices from 50 to 1000 in increments of 50
    time_sparse, time_dense = measure_time_matrix_directed(vertex_range)

    # Fit best-fit lines (polynomial regression) with degree 3
    sparse_fit = polynomial_fit(vertex_range, time_sparse, 3)
    dense_fit = polynomial_fit(vertex_range, time_dense, 3)

    # Plot original data
    plt.plot(vertex_range, time_sparse, 'o', label="Sparse Graph (Directed, Matrix)", markersize=4)
    plt.plot(vertex_range, time_dense, 'o', label="Dense Graph (Directed, Matrix)", markersize=4)

    # Plot best-fit lines
    plt.plot(vertex_range, sparse_fit, label="Best-Fit Line (Sparse Graph)", linestyle='--', color='blue')
    plt.plot(vertex_range, dense_fit, label="Best-Fit Line (Dense Graph)", linestyle='--', color='red')

    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency Matrix): Sparse vs Dense (Vertices 50 to 1000)')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_a_with_fit()

"""## **For varying edges**"""

import sys
import random
import time
import matplotlib.pyplot as plt
import numpy as np

# Function to generate a directed graph with varying edges
def generate_directed_graph(vertices, edges):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight  # Directed graph, only u -> v
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency matrix for directed graph
def dijkstra_matrix_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices

    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1

        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v

        u = min_index
        visited[u] = True

        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]

    return dist

# Measure the execution time for fixed vertices and varying edges
def measure_time_matrix_directed(vertices, edge_range):
    time_results = []

    for edges in edge_range:
        graph = generate_directed_graph(vertices, edges)

        # Measure time for the graph with the specified number of edges
        start_time = time.time()
        dijkstra_matrix_directed(graph, 0)
        time_results.append(time.time() - start_time)

    return time_results

# Function to add polynomial best-fit line
def polynomial_fit(x, y, degree):
    coefficients = np.polyfit(x, y, degree)
    polynomial = np.poly1d(coefficients)
    return polynomial(x)

# Plotting results for fixed vertices (100 and 1000) with varying edges
def plot_results_with_fit():
    # Fixed vertices = 100, edges vary from sparse (99) to dense (100 * (100 - 1) = 9900) with increments of 10
    vertex_100 = 100
    edge_range_100 = list(range(99, 9901, 100))  # Edges from 99 (sparse) to 9900 (dense)
    time_100 = measure_time_matrix_directed(vertex_100, edge_range_100)

    # Fixed vertices = 1000, edges vary from sparse (999) to dense (1000 * (1000 - 1) = 999000) with increments of 100
    vertex_1000 = 1000
    edge_range_1000 = list(range(999, 999001, 10000))  # Edges from 999 (sparse) to 999000 (dense)
    time_1000 = measure_time_matrix_directed(vertex_1000, edge_range_1000)

    # Fit best-fit lines (polynomial regression) with degree 3
    fit_100 = polynomial_fit(edge_range_100, time_100, 3)
    fit_1000 = polynomial_fit(edge_range_1000, time_1000, 3)

    # Plot for vertices = 100
    plt.figure(figsize=(10, 5))
    plt.plot(edge_range_100, time_100, 'o', label="Execution Time (Vertices = 100)", markersize=4)
    plt.plot(edge_range_100, fit_100, label="Best-Fit Line (Vertices = 100)", linestyle='--', color='blue')
    plt.xlabel('Number of Edges')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency Matrix): Vertices = 100, Varying Edges')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Plot for vertices = 1000
    plt.figure(figsize=(10, 5))
    plt.plot(edge_range_1000, time_1000, 'o', label="Execution Time (Vertices = 1000)", markersize=4)
    plt.plot(edge_range_1000, fit_1000, label="Best-Fit Line (Vertices = 1000)", linestyle='--', color='red')
    plt.xlabel('Number of Edges')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency Matrix): Vertices = 1000, Varying Edges')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_with_fit()

"""## **Part B Test 2**"""

import heapq
import random
import time
import matplotlib.pyplot as plt
import sys

# Function to generate a sparse or dense directed graph as adjacency list
def generate_directed_graph_list(vertices, edges):
    graph = {i: [] for i in range(vertices)}
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and all(v != dest for dest, _ in graph[u]):
            weight = random.randint(1, 10)
            graph[u].append((v, weight))
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency list for directed graph
def dijkstra_list_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    priority_queue = [(0, src)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)

        if current_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            distance = current_dist + weight
            if distance < dist[v]:
                dist[v] = distance
                heapq.heappush(priority_queue, (distance, v))

    return dist

# Measure the execution time for varying vertices for sparse and dense directed graphs using adjacency list
def measure_time_list_directed(vertex_range):
    time_results_sparse = []
    time_results_dense = []

    for v in vertex_range:
        sparse_edges = v - 1  # Sparse graph with v-1 edges
        dense_edges = v * (v - 1)  # Dense graph with max edges for directed graph

        sparse_graph = generate_directed_graph_list(v, sparse_edges)
        dense_graph = generate_directed_graph_list(v, dense_edges)

        # Measure time for sparse graph
        start_time = time.time()
        dijkstra_list_directed(sparse_graph, 0)
        time_results_sparse.append(time.time() - start_time)

        # Measure time for dense graph
        start_time = time.time()
        dijkstra_list_directed(dense_graph, 0)
        time_results_dense.append(time.time() - start_time)

    return time_results_sparse, time_results_dense

# Plotting results for vertices from 1 to 100 in increments of 10
def plot_results_part_b():
    vertex_range = list(range(1, 101, 10))  # Vertices from 50 to 1000 in increments of 100
    time_sparse, time_dense = measure_time_list_directed(vertex_range)

    plt.plot(vertex_range, time_sparse, label="Sparse Graph (Directed, List)")
    plt.plot(vertex_range, time_dense, label="Dense Graph (Directed, List)")
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency List): Sparse vs Dense (Vertices 1 to 100)')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_b()

import heapq
import random
import time
import matplotlib.pyplot as plt
import numpy as np
import sys

# Function to generate a sparse or dense directed graph as adjacency list
def generate_directed_graph_list(vertices, edges):
    graph = {i: [] for i in range(vertices)}
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and all(v != dest for dest, _ in graph[u]):
            weight = random.randint(1, 10)
            graph[u].append((v, weight))
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency list for directed graph
def dijkstra_list_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    priority_queue = [(0, src)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)

        if current_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            distance = current_dist + weight
            if distance < dist[v]:
                dist[v] = distance
                heapq.heappush(priority_queue, (distance, v))

    return dist

# Measure the execution time for varying vertices for sparse and dense directed graphs using adjacency list
def measure_time_list_directed(vertex_range):
    time_results_sparse = []
    time_results_dense = []

    for v in vertex_range:
        sparse_edges = v - 1  # Sparse graph with v-1 edges
        dense_edges = v * (v - 1)  # Dense graph with max edges for directed graph

        sparse_graph = generate_directed_graph_list(v, sparse_edges)
        dense_graph = generate_directed_graph_list(v, dense_edges)

        # Measure time for sparse graph
        start_time = time.time()
        dijkstra_list_directed(sparse_graph, 0)
        runtime_sparse = time.time() - start_time
        time_results_sparse.append(runtime_sparse)
        print(f"Vertices: {v}, Sparse Graph Runtime: {runtime_sparse:.5f} seconds")

        # Measure time for dense graph
        start_time = time.time()
        dijkstra_list_directed(dense_graph, 0)
        runtime_dense = time.time() - start_time
        time_results_dense.append(runtime_dense)
        print(f"Vertices: {v}, Dense Graph Runtime: {runtime_dense:.5f} seconds")

    return time_results_sparse, time_results_dense

# Function to add polynomial best-fit line
def polynomial_fit(x, y, degree):
    coefficients = np.polyfit(x, y, degree)
    polynomial = np.poly1d(coefficients)
    return polynomial(x)

# Plotting results for vertices from 100 to 1000 in increments of 100 with best-fit line
def plot_results_part_b_with_fit():
    vertex_range = list(range(1, 101, 10))  # Vertices from 100 to 1000 in increments of 100
    time_sparse, time_dense = measure_time_list_directed(vertex_range)

    # Fit best-fit lines (polynomial regression) with degree 3
    sparse_fit = polynomial_fit(vertex_range, time_sparse, 3)
    dense_fit = polynomial_fit(vertex_range, time_dense, 3)

    # Plot original data
    plt.plot(vertex_range, time_sparse, 'o', label="Sparse Graph (Directed, List)", markersize=4)
    plt.plot(vertex_range, time_dense, 'o', label="Dense Graph (Directed, List)", markersize=4)

    # Plot best-fit lines
    plt.plot(vertex_range, sparse_fit, label="Best-Fit Line (Sparse Graph)", linestyle='--', color='blue')
    plt.plot(vertex_range, dense_fit, label="Best-Fit Line (Dense Graph)", linestyle='--', color='red')

    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency List): Sparse vs Dense (Vertices 100 to 1000)')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_part_b_with_fit()

"""## For varying E"""

import sys
import heapq
import random
import time
import matplotlib.pyplot as plt
import numpy as np

# Function to generate a directed graph with varying edges as adjacency list
def generate_directed_graph_list(vertices, edges):
    graph = {i: [] for i in range(vertices)}
    edge_count = 0

    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and all(v != dest for dest, _ in graph[u]):
            weight = random.randint(1, 10)
            graph[u].append((v, weight))
            edge_count += 1

    return graph

# Dijkstra's algorithm using adjacency list for directed graph
def dijkstra_list_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    priority_queue = [(0, src)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)

        if current_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            distance = current_dist + weight
            if distance < dist[v]:
                dist[v] = distance
                heapq.heappush(priority_queue, (distance, v))

    return dist

# Measure the execution time for fixed vertices and varying edges
def measure_time_list_directed(vertices, edge_range):
    time_results = []

    for edges in edge_range:
        graph = generate_directed_graph_list(vertices, edges)

        # Measure time for the graph with the specified number of edges
        start_time = time.time()
        dijkstra_list_directed(graph, 0)
        time_results.append(time.time() - start_time)

    return time_results

# Function to add polynomial best-fit line
def polynomial_fit(x, y, degree):
    coefficients = np.polyfit(x, y, degree)
    polynomial = np.poly1d(coefficients)
    return polynomial(x)

# Plotting results for fixed vertices (100 and 1000) with varying edges
def plot_results_with_fit():
    # Fixed vertices = 100, edges vary from sparse (99) to dense (100 * (100 - 1) = 9900) with increments of 10
    vertex_100 = 100
    edge_range_100 = list(range(99, 9901, 100))  # Edges from 99 (sparse) to 9900 (dense)
    time_100 = measure_time_list_directed(vertex_100, edge_range_100)

    # Fixed vertices = 1000, edges vary from sparse (999) to dense (1000 * (1000 - 1) = 999000) with increments of 100
    vertex_1000 = 1000
    edge_range_1000 = list(range(999, 999001, 10000))  # Edges from 999 (sparse) to 999000 (dense)
    time_1000 = measure_time_list_directed(vertex_1000, edge_range_1000)

    # Fit best-fit lines (polynomial regression) with degree 3
    fit_100 = polynomial_fit(edge_range_100, time_100, 3)
    fit_1000 = polynomial_fit(edge_range_1000, time_1000, 3)

    # Plot for vertices = 100
    plt.figure(figsize=(10, 5))
    plt.plot(edge_range_100, time_100, 'o', label="Execution Time (Vertices = 100)", markersize=4)
    plt.plot(edge_range_100, fit_100, label="Best-Fit Line (Vertices = 100)", linestyle='--', color='blue')
    plt.xlabel('Number of Edges')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency List): Vertices = 100, Varying Edges')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Plot for vertices = 1000
    plt.figure(figsize=(10, 5))
    plt.plot(edge_range_1000, time_1000, 'o', label="Execution Time (Vertices = 1000)", markersize=4)
    plt.plot(edge_range_1000, fit_1000, label="Best-Fit Line (Vertices = 1000)", linestyle='--', color='red')
    plt.xlabel('Number of Edges')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Dijkstra\'s Algorithm (Adjacency List): Vertices = 1000, Varying Edges')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_results_with_fit()

"""## **Part C**"""

import heapq
import random
import time
import matplotlib.pyplot as plt
import numpy as np

# Function to generate a sparse or dense directed graph as adjacency matrix
def generate_directed_graph_matrix(vertices, edges):
    graph = [[0 for _ in range(vertices)] for _ in range(vertices)]
    edge_count = 0
    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and graph[u][v] == 0:
            weight = random.randint(1, 10)
            graph[u][v] = weight
            edge_count += 1
    return graph

# Function to generate a sparse or dense directed graph as adjacency list
def generate_directed_graph_list(vertices, edges):
    graph = {i: [] for i in range(vertices)}
    edge_count = 0
    while edge_count < edges:
        u = random.randint(0, vertices - 1)
        v = random.randint(0, vertices - 1)
        if u != v and all(v != dest for dest, _ in graph[u]):
            weight = random.randint(1, 10)
            graph[u].append((v, weight))
            edge_count += 1
    return graph

# Dijkstra's algorithm using adjacency matrix for directed graph
def dijkstra_matrix_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    visited = [False] * vertices
    for _ in range(vertices):
        min_distance = sys.maxsize
        min_index = -1
        for v in range(vertices):
            if not visited[v] and dist[v] < min_distance:
                min_distance = dist[v]
                min_index = v
        u = min_index
        visited[u] = True
        for v in range(vertices):
            if graph[u][v] > 0 and not visited[v] and dist[v] > dist[u] + graph[u][v]:
                dist[v] = dist[u] + graph[u][v]
    return dist

# Dijkstra's algorithm using adjacency list for directed graph
def dijkstra_list_directed(graph, src):
    vertices = len(graph)
    dist = [sys.maxsize] * vertices
    dist[src] = 0
    priority_queue = [(0, src)]
    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)
        if current_dist > dist[u]:
            continue
        for v, weight in graph[u]:
            distance = current_dist + weight
            if distance < dist[v]:
                dist[v] = distance
                heapq.heappush(priority_queue, (distance, v))
    return dist

# Measure execution time for varying vertices for sparse and dense directed graphs
def measure_time(vertex_range, is_sparse):
    time_results_matrix = []
    time_results_list = []
    for v in vertex_range:
        edges = v - 1 if is_sparse else v * (v - 1) // 2
        sparse_graph_matrix = generate_directed_graph_matrix(v, edges)
        sparse_graph_list = generate_directed_graph_list(v, edges)
        # Measure time for matrix
        start_time = time.time()
        dijkstra_matrix_directed(sparse_graph_matrix, 0)
        time_results_matrix.append(time.time() - start_time)
        # Measure time for list
        start_time = time.time()
        dijkstra_list_directed(sparse_graph_list, 0)
        time_results_list.append(time.time() - start_time)
    return time_results_matrix, time_results_list

# Polynomial fit function to get best-fit lines
def polynomial_fit(x, y, degree):
    coefficients = np.polyfit(x, y, degree)
    polynomial = np.poly1d(coefficients)
    return polynomial(x)

# Plot results for sparse and dense graphs (matrix vs list comparison)
def plot_comparison(is_sparse):
    vertex_range = list(range(50, 1601, 200))  # Vertices from 50 to 1000 in increments of 50
    time_matrix, time_list = measure_time(vertex_range, is_sparse)

    # Fit best-fit lines (polynomial regression)
    matrix_fit = polynomial_fit(vertex_range, time_matrix, 3)
    list_fit = polynomial_fit(vertex_range, time_list, 3)

    # Plot best-fit lines for matrix and list
    plt.plot(vertex_range, matrix_fit, label="Adjacency Matrix Best-Fit", linestyle='--', color='blue')
    plt.plot(vertex_range, list_fit, label="Adjacency List Best-Fit", linestyle='--', color='red')

    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    title_type = "Sparse" if is_sparse else "Dense"
    plt.title(f'Dijkstra\'s Algorithm: {title_type} Graphs Comparison (Matrix vs List)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plot for sparse and dense graphs
def plot_all():
    # Plot for sparse graphs
    plot_comparison(is_sparse=True)
    # Plot for dense graphs
    plot_comparison(is_sparse=False)

plot_all()

